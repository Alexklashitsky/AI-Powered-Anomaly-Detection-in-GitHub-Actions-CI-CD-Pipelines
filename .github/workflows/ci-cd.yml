name: Flask CI/CD Pipeline

on:
  push:
    branches:
      - main
  workflow_run:
    workflows: ["Terraform Infrastructure Deployment"]
    types:
      - completed
    branches:
      - main

permissions:
  id-token: write
  contents: read

jobs:
  build:
    name: Build and Test
    runs-on: ubuntu-latest
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'
      
      - name: Install dependencies
        run: |
          python -m pip install --upgrade pip
          pip install -r requirements.txt
          pip install pytest pytest-cov
      
      - name: Run tests
        run: |
          pytest --cov=. --cov-report=xml --cov-report=term
      
      - name: Upload test results
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: test-results
          path: coverage.xml

  deploy:
    name: Deploy to Azure App Service
    runs-on: ubuntu-latest
    needs: build
    # Only run if triggered by successful Terraform deployment or manual push
    if: |
      (github.event_name == 'workflow_run' && github.event.workflow_run.conclusion == 'success') ||
      (github.event_name == 'push' && !contains(github.event.head_commit.modified, 'terraform/'))
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false
      
      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      
      - name: Get Terraform Outputs
        id: tf_outputs
        run: |
          cd terraform
          
          # Initialize Terraform to access remote state
          terraform init \
            -backend-config="resource_group_name=terraform-state-rg" \
            -backend-config="storage_account_name=tfstatedevopsdelk" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=flask-app.terraform.tfstate"
          
          # Get outputs from Terraform state
          APP_SERVICE_NAME=$(terraform output -raw app_service_name)
          RESOURCE_GROUP_NAME=$(terraform output -raw resource_group_name)
          ACR_NAME=$(terraform output -raw acr_name)
          ACR_LOGIN_SERVER=$(terraform output -raw acr_login_server)
          
          # Export to GitHub outputs
          echo "app_service_name=$APP_SERVICE_NAME" >> $GITHUB_OUTPUT
          echo "resource_group_name=$RESOURCE_GROUP_NAME" >> $GITHUB_OUTPUT
          echo "acr_name=$ACR_NAME" >> $GITHUB_OUTPUT
          echo "acr_login_server=$ACR_LOGIN_SERVER" >> $GITHUB_OUTPUT
          
          echo "âœ… Retrieved Terraform outputs:"
          echo "  App Service: $APP_SERVICE_NAME"
          echo "  Resource Group: $RESOURCE_GROUP_NAME"
          echo "  ACR: $ACR_NAME"
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_USE_OIDC: true
      
      - name: Build and push Docker image to Azure Container Registry
        run: |
          ACR_NAME="${{ steps.tf_outputs.outputs.acr_name }}"
          ACR_LOGIN_SERVER="${{ steps.tf_outputs.outputs.acr_login_server }}"
          IMAGE_NAME="flask-app"
          IMAGE_TAG="${{ github.sha }}"
          
          echo "ðŸ³ Building and pushing Docker image to $ACR_LOGIN_SERVER"
          
          # Login to ACR
          az acr login --name $ACR_NAME
          
          # Build and push image
          docker build -t $ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG .
          docker build -t $ACR_LOGIN_SERVER/$IMAGE_NAME:latest .
          docker push $ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG
          docker push $ACR_LOGIN_SERVER/$IMAGE_NAME:latest
      
      - name: Deploy to Azure App Service
        run: |
          APP_NAME="${{ steps.tf_outputs.outputs.app_service_name }}"
          RESOURCE_GROUP="${{ steps.tf_outputs.outputs.resource_group_name }}"
          ACR_LOGIN_SERVER="${{ steps.tf_outputs.outputs.acr_login_server }}"
          IMAGE_NAME="flask-app"
          IMAGE_TAG="${{ github.sha }}"
          
          echo "ðŸš€ Deploying to App Service: $APP_NAME"
          
          # Deploy container to App Service
          az webapp config container set \
            --name $APP_NAME \
            --resource-group $RESOURCE_GROUP \
            --docker-custom-image-name $ACR_LOGIN_SERVER/$IMAGE_NAME:$IMAGE_TAG \
            --docker-registry-server-url https://$ACR_LOGIN_SERVER
          
          # Restart the app service to apply changes
          az webapp restart --name $APP_NAME --resource-group $RESOURCE_GROUP
          
          echo "âœ… Deployment completed successfully!"
          echo "ðŸŒ App URL: https://$(az webapp show --name $APP_NAME --resource-group $RESOURCE_GROUP --query defaultHostName -o tsv)"
      
      - name: Logout from Azure
        if: always()
        run: |
          az logout

  monitor:
    name: AI-Powered Anomaly Detection
    runs-on: ubuntu-latest
    needs: deploy
    if: always() && needs.deploy.result != 'skipped'
    
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
      
      - name: Setup Terraform
        uses: hashicorp/setup-terraform@v3
        with:
          terraform_version: 1.6.0
          terraform_wrapper: false
      
      - name: Azure Login (OIDC)
        uses: azure/login@v2
        with:
          client-id: ${{ secrets.AZURE_CLIENT_ID }}
          tenant-id: ${{ secrets.AZURE_TENANT_ID }}
          subscription-id: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
      
      - name: Get Infrastructure Configuration
        id: infra_config
        run: |
          cd terraform
          
          # Initialize Terraform to access remote state
          terraform init \
            -backend-config="resource_group_name=terraform-state-rg" \
            -backend-config="storage_account_name=tfstatedevopsdelk" \
            -backend-config="container_name=tfstate" \
            -backend-config="key=flask-app.terraform.tfstate"
          
          # Get outputs from Terraform state
          FUNCTION_APP_NAME=$(terraform output -raw function_app_name || echo "")
          RESOURCE_GROUP_NAME=$(terraform output -raw resource_group_name)
          APP_SERVICE_NAME=$(terraform output -raw app_service_name)
          
          # Export to GitHub outputs
          echo "function_app_name=$FUNCTION_APP_NAME" >> $GITHUB_OUTPUT
          echo "resource_group_name=$RESOURCE_GROUP_NAME" >> $GITHUB_OUTPUT
          echo "app_service_name=$APP_SERVICE_NAME" >> $GITHUB_OUTPUT
          
          echo "âœ… Retrieved infrastructure configuration"
        env:
          ARM_CLIENT_ID: ${{ secrets.AZURE_CLIENT_ID }}
          ARM_SUBSCRIPTION_ID: ${{ secrets.AZURE_SUBSCRIPTION_ID }}
          ARM_TENANT_ID: ${{ secrets.AZURE_TENANT_ID }}
          ARM_USE_OIDC: true
      
      - name: Query Pipeline Metrics from Azure Monitor
        id: metrics
        run: |
          echo "ðŸ“Š Querying pipeline metrics..."
          
          # Get current pipeline metrics
          START_TIME=$(date -u -d '5 minutes ago' '+%Y-%m-%dT%H:%M:%SZ')
          END_TIME=$(date -u '+%Y-%m-%dT%H:%M:%SZ')
          BUILD_ID="${{ github.run_id }}"
          
          # Get workflow duration (in seconds)
          WORKFLOW_START_TIME="${{ github.event.workflow_run.created_at || github.event.created_at }}"
          CURRENT_TIME=$(date +%s)
          START_TIMESTAMP=$(date -d "$WORKFLOW_START_TIME" +%s 2>/dev/null || echo "$CURRENT_TIME")
          DURATION=$((CURRENT_TIME - START_TIMESTAMP))
          
          # Calculate failure rate based on job status
          if [ "${{ needs.deploy.result }}" == "success" ]; then
            FAILURE_RATE=0.0
          else
            FAILURE_RATE=1.0
          fi
          
          # Store metrics
          echo "build_id=$BUILD_ID" >> $GITHUB_OUTPUT
          echo "duration=$DURATION" >> $GITHUB_OUTPUT
          echo "failure_rate=$FAILURE_RATE" >> $GITHUB_OUTPUT
          
          echo "âœ… Pipeline Metrics:"
          echo "  Build ID: $BUILD_ID"
          echo "  Duration: ${DURATION}s"
          echo "  Failure Rate: $FAILURE_RATE"
      
      - name: Call Anomaly Detection Function
        id: anomaly_check
        continue-on-error: true
        run: |
          FUNCTION_APP_NAME="${{ steps.infra_config.outputs.function_app_name }}"
          
          if [ -z "$FUNCTION_APP_NAME" ]; then
            echo "âš ï¸ Function App not deployed yet, skipping anomaly detection"
            echo "anomalies_detected=0" >> $GITHUB_OUTPUT
            echo "anomaly_check_status=skipped" >> $GITHUB_OUTPUT
            exit 0
          fi
          
          FUNCTION_URL="https://${FUNCTION_APP_NAME}.azurewebsites.net/api/detect_anomalies"
          
          echo "ðŸ¤– Calling anomaly detection function: $FUNCTION_URL"
          
          # Prepare metrics payload
          METRICS_JSON=$(cat <<EOF
          {
            "data": [{
              "build_id": "${{ steps.metrics.outputs.build_id }}",
              "duration": ${{ steps.metrics.outputs.duration }},
              "failure_rate": ${{ steps.metrics.outputs.failure_rate }}
            }]
          }
          EOF
          )
          
          # Call function endpoint
          RESPONSE=$(curl -s -X POST "$FUNCTION_URL" \
            -H "Content-Type: application/json" \
            -d "$METRICS_JSON" \
            -w "\n%{http_code}" || echo "000")
          
          HTTP_CODE=$(echo "$RESPONSE" | tail -n1)
          BODY=$(echo "$RESPONSE" | sed '$d')
          
          if [ "$HTTP_CODE" == "200" ]; then
            echo "âœ… Anomaly detection completed successfully"
            echo "$BODY" | jq '.'
            
            # Extract anomaly count
            ANOMALIES=$(echo "$BODY" | jq -r '.anomalies_detected // 0')
            echo "anomalies_detected=$ANOMALIES" >> $GITHUB_OUTPUT
            echo "anomaly_check_status=success" >> $GITHUB_OUTPUT
            
            # Store full response for later use
            echo "$BODY" > anomaly_results.json
            
          else
            echo "âš ï¸ Function returned status code: $HTTP_CODE"
            echo "Response: $BODY"
            echo "anomalies_detected=0" >> $GITHUB_OUTPUT
            echo "anomaly_check_status=error" >> $GITHUB_OUTPUT
          fi
      
      - name: Analyze Anomaly Results
        if: steps.anomaly_check.outputs.anomaly_check_status == 'success'
        run: |
          ANOMALIES=${{ steps.anomaly_check.outputs.anomalies_detected }}
          
          if [ "$ANOMALIES" -gt 0 ]; then
            echo "ðŸš¨ ANOMALY DETECTED!"
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "This pipeline run shows anomalous behavior:"
            
            if [ -f anomaly_results.json ]; then
              echo ""
              cat anomaly_results.json | jq -r '.anomalies[] | "  â€¢ Build: \(.build_id)\n    Duration: \(.duration)s\n    Failure Rate: \(.failure_rate * 100)%\n    Anomaly Score: \(.anomaly_score)"'
            fi
            
            echo "â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”"
            echo "âš ï¸ Review required: This build may have performance issues"
          else
            echo "âœ… No anomalies detected - pipeline behavior is normal"
          fi
      
      - name: Create GitHub Issue for Anomaly
        if: steps.anomaly_check.outputs.anomalies_detected > 0
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            let anomalyDetails = 'No details available';
            
            try {
              const results = JSON.parse(fs.readFileSync('anomaly_results.json', 'utf8'));
              anomalyDetails = results.anomalies.map(a => 
                `- **Build**: ${a.build_id}\n  - Duration: ${a.duration}s\n  - Failure Rate: ${(a.failure_rate * 100).toFixed(1)}%\n  - Anomaly Score: ${a.anomaly_score}`
              ).join('\n');
            } catch (e) {
              console.log('Could not read anomaly results');
            }
            
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `ðŸš¨ Pipeline Anomaly Detected - Run #${{ github.run_number }}`,
              body: `## Pipeline Anomaly Alert
            
            An anomaly was detected in the CI/CD pipeline by our AI-powered monitoring system.
            
            ### Run Details
            - **Workflow**: ${{ github.workflow }}
            - **Run ID**: ${{ github.run_id }}
            - **Run Number**: ${{ github.run_number }}
            - **Triggered by**: @${{ github.actor }}
            - **Commit**: ${{ github.sha }}
            - **Branch**: ${{ github.ref_name }}
            
            ### Anomaly Details
            ${anomalyDetails}
            
            ### Recommendations
            1. Review the workflow execution logs
            2. Check for infrastructure issues in Azure
            3. Compare with recent successful runs
            4. Investigate any recent code or configuration changes
            
            ### Links
            - [Workflow Run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }})
            - [Azure Portal](https://portal.azure.com)
            - [Azure ML Studio](https://ml.azure.com)
            
            ---
            *This issue was automatically created by the AI-Powered Anomaly Detection system.*`,
              labels: ['anomaly', 'ci-cd', 'automated']
            });
            
            console.log(`Created issue #${issue.data.number}`);
      
      - name: Send Notification Comment
        if: steps.anomaly_check.outputs.anomalies_detected > 0 && github.event_name == 'pull_request'
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.issue.number,
              body: `## âš ï¸ Pipeline Anomaly Detected
            
            The AI-powered monitoring system has detected anomalous behavior in this pipeline run.
            
            **Build ID**: ${{ steps.metrics.outputs.build_id }}
            **Duration**: ${{ steps.metrics.outputs.duration }}s
            **Anomalies Found**: ${{ steps.anomaly_check.outputs.anomalies_detected }}
            
            Please review the [workflow run](https://github.com/${{ github.repository }}/actions/runs/${{ github.run_id }}) for more details.
            
            *This may indicate performance issues or infrastructure problems that need attention.*`
            });
      
      - name: Fail Build on Critical Anomaly (Optional)
        if: steps.anomaly_check.outputs.anomalies_detected > 0 && github.event_name == 'pull_request'
        run: |
          echo "::warning::Pipeline anomaly detected - consider investigating before merging"
          # Uncomment the line below to fail the build on anomalies:
          # exit 1
      
      - name: Upload Anomaly Report
        if: always() && steps.anomaly_check.outputs.anomaly_check_status == 'success'
        uses: actions/upload-artifact@v4
        with:
          name: anomaly-detection-report-${{ github.run_number }}
          path: |
            anomaly_results.json
          retention-days: 30
      
      - name: Logout from Azure
        if: always()
        run: |
          az logout
